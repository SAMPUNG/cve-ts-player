import { ToClientMessageType, WS_OPEN_STATE } from '../dictionary'
import { emit } from '../player/emitter'
import { resize } from '../style/resolution'
import { emitUIInteraction } from './emitter'
import { ws } from './web-socket'
import { open } from '../player/play-control'
import { player } from '../player/custom-element'

export interface ResponseData {
  Code?: string
  /** 指令 */
  Command?: string
  /** 响应数据 */
  Data?: unknown
  Result?: unknown
  /** 类型 */
  Type?: string
  /** UID */
  UID?: string
}

export interface ResponseRecord {
  /** Date value */
  RequestDateTime: number
  ResponseData: ResponseData
}

export let dc: RTCDataChannel | undefined

export function createDataChannel(
  pc: RTCPeerConnection,
  label: string,
  options?: RTCDataChannelInit
) {
  // This is the primary data channel code path when we are "offering"
  let datachannel = pc.createDataChannel(label, options)
  setupDataChannelCallbacks(datachannel)
  return datachannel
}

function onDataChannelConnected() {
  if (ws?.readyState === WS_OPEN_STATE) {
    emitUIInteraction({ Console: 'PixelStreaming.Encoder.MaxQP 36' })
    emitUIInteraction({ Command: 'SetVolume', Data: player?.volume })

    open()

    resize(player?.getAttribute('aspect-ratio'))

    emit('text', 'WebRTC connected, waiting for video')
    emit('connect', Date.now())
  }
}

function onDataChannelMessage(data: ArrayBuffer) {
  const view = new Uint8Array(data)
  if (view[0] === ToClientMessageType.Response) {
    const response = new TextDecoder('utf-16').decode(data.slice(1))
    onPixelStreamingResponse(response)
  }
}

export const responseMap: Map<string, ResponseRecord> = new Map()
function onPixelStreamingResponse(data: string) {
  const jsonData = JSON.parse(data)
  if (jsonData.Type === 'Command') {
    const uid = jsonData.UID
    //命令行指令返回的数据
    if (!uid) {
      return
    }
    const response = responseMap.get(uid)
    if (response) {
      response.ResponseData = jsonData
    }
  } else if (jsonData.Type === 'Action') {
    if (jsonData.Action == 'SceneInitialized') {
      emit('init', jsonData.Data)
    } else if (jsonData.Action == 'PointClicked') {
      emit('select', JSON.parse(jsonData.Data))
    } else if (jsonData.Action == 'PolygonClicked') {
      emit('select', JSON.parse(jsonData.Data))
    } else if (jsonData.Action == 'MeasureFinished') {
      emit('measure', jsonData.Data)
    } else {
      emit('render', jsonData)
    }
  }
}

export function setupDataChannelCallbacks(datachannel: RTCDataChannel) {
  try {
    // Inform browser we would like binary data as an ArrayBuffer (FF chooses Blob by default!)
    datachannel.binaryType = 'arraybuffer'

    datachannel.addEventListener('open', () => {
      onDataChannelConnected()
    })

    datachannel.addEventListener('message', (e) => {
      onDataChannelMessage(e.data)
      emit('message', e.data)
    })

    return datachannel
  } catch (e) {
    return null
  }
}

export function updateDataChannel(dataChannel?: RTCDataChannel) {
  dc = dataChannel
}

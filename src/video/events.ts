import {
  InputOptions,
  MessageType,
  MouseButton,
  MouseButtonsMask,
} from '@cve-ts/dictionary'
import video from './element'
import { emitMouseDown, emitMouseMove, emitMouseUp, emitMouseWheel } from './emitter'
import { send } from '../liaison/emitter'
import { normalizeAndQuantizeUnsigned, rect } from '../wrapper/coords'

interface CveStyle {
  cursor: string
  height: number
  left: number
  top: number
  width: number
}

interface FingerRecord {
  id: number
  x: number
  y: number
}

export const css: CveStyle = {
  cursor: 'default',
  height: 1080,
  left: 0,
  top: 0,
  width: 1920,
}

function pressMouseButton(buttons: number, x: number, y: number) {
  if (buttons & MouseButtonsMask.PrimaryButton) {
    emitMouseDown(MouseButton.MainButton, x, y)
  }
  if (buttons & MouseButtonsMask.SecondaryButton) {
    emitMouseDown(MouseButton.SecondaryButton, x, y)
  }
  if (buttons & MouseButtonsMask.AuxiliaryButton) {
    emitMouseDown(MouseButton.AuxiliaryButton, x, y)
  }
  if (buttons & MouseButtonsMask.FourthButton) {
    emitMouseDown(MouseButton.FourthButton, x, y)
  }
  if (buttons & MouseButtonsMask.FifthButton) {
    emitMouseDown(MouseButton.FifthButton, x, y)
  }
}

function releaseMouseButton(buttons: number, x: number, y: number) {
  if (buttons & MouseButtonsMask.PrimaryButton) {
    emitMouseUp(MouseButton.MainButton, x, y)
  }
  if (buttons & MouseButtonsMask.SecondaryButton) {
    emitMouseUp(MouseButton.SecondaryButton, x, y)
  }
  if (buttons & MouseButtonsMask.AuxiliaryButton) {
    emitMouseUp(MouseButton.AuxiliaryButton, x, y)
  }
  if (buttons & MouseButtonsMask.FourthButton) {
    emitMouseUp(MouseButton.FourthButton, x, y)
  }
  if (buttons & MouseButtonsMask.FifthButton) {
    emitMouseUp(MouseButton.FifthButton, x, y)
  }
}

export function registerHoveringMouseEvents() {
  css.cursor = 'default'

  video.onmousemove = (e) => {
    emitMouseMove(e.offsetX, e.offsetY, e.movementX, e.movementY)
    e.preventDefault()
  }

  video.onmousedown = (e) => {
    emitMouseDown(e.button, e.offsetX, e.offsetY)
    e.preventDefault()
  }

  video.onmouseup = (e) => {
    emitMouseUp(e.button, e.offsetX, e.offsetY)
    e.preventDefault()
  }

  // When the context menu is shown then it is safest to release the button
  // which was pressed when the event happened. This will guarantee we will
  // get at least one mouse up corresponding to a mouse down event. Otherwise
  // the mouse can get stuck.
  // https://github.com/facebook/react/issues/5531
  video.oncontextmenu = (e) => {
    emitMouseUp(e.button, e.offsetX, e.offsetY)
    e.preventDefault()
  }

  if ('onmousewheel' in video) {
    video.onmousewheel = (e) => {
      emitMouseWheel(e.wheelDelta!, e.offsetX, e.offsetY)
      e.preventDefault()
    }
  } else {
    video.addEventListener(
      'DOMMouseScroll',
      (e) => {
        emitMouseWheel(
          (e as CustomEvent).detail * -120,
          (e as MouseEvent).offsetX,
          (e as MouseEvent).offsetY
        )
        e.preventDefault()
      },
      false
    )
  }

  video.pressMouseButtons = (e) => {
    pressMouseButton(e.buttons, e.offsetX, e.offsetY)
  }

  video.releaseMouseButtons = (e) => {
    releaseMouseButton(e.buttons, e.offsetX, e.offsetY)
  }
}

export function registerLockedMouseEvents() {
  let x = video.clientWidth / 2
  let y = video.clientHeight / 2

  video.requestPointerLock =
    video.requestPointerLock || video.mozRequestPointerLock
  document.exitPointerLock =
    document.exitPointerLock || document.mozExitPointerLock

  video.onclick = () => {
    video.requestPointerLock()
  }

  // Respond to lock state change events
  document.addEventListener('pointerlockchange', lockStateChange, false)
  document.addEventListener('mozpointerlockchange', lockStateChange, false)

  video.onmousedown = (e) => {
    emitMouseDown(e.button, x, y)
  }

  video.onmouseup = (e) => {
    emitMouseUp(e.button, x, y)
  }

  if (video.onmousewheel) {
    video.onmousewheel = (e) => {
      emitMouseWheel(e.wheelDelta!, x, y)
    }
  }

  video.pressMouseButtons = (e) => {
    pressMouseButton(e.buttons, x, y)
  }

  video.releaseMouseButtons = (e) => {
    releaseMouseButton(e.buttons, x, y)
  }

  function lockStateChange() {
    if (
      document.pointerLockElement === video ||
      document.mozPointerLockElement === video
    ) {
      document.addEventListener('mousemove', updatePosition, false)
    } else {
      document.removeEventListener('mousemove', updatePosition, false)
    }
  }

  const updatePosition = (ev: MouseEvent) => {
    x += ev.movementX
    y += ev.movementY
    if (x > css.width) {
      x -= css.width
    }
    if (y > css.height) {
      y -= css.height
    }
    if (x < 0) {
      x += css.width
    }
    if (y < 0) {
      y += css.height
    }
    emitMouseMove(x, y, ev.movementX, ev.movementY)
  }
}

export function registerMouseEnterAndLeaveEvents() {
  video.onmouseenter = (e) => {
    const Data = new DataView(new ArrayBuffer(1))
    Data.setUint8(0, MessageType.MouseEnter)
    send(Data.buffer)
    video.pressMouseButtons?.(e)
  }

  video.onmouseleave = (e) => {
    const Data = new DataView(new ArrayBuffer(1))
    Data.setUint8(0, MessageType.MouseLeave)
    send(Data.buffer)
    video.releaseMouseButtons?.(e)
  }
}

export function registerTouchEvents() {
  // We need to assign a unique identifier to each finger.
  // We do this by mapping each Touch object to the identifier.
  const fingers: number[] = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
  const fingerIds: Record<number, number> = {}

  function rememberTouch(touch: Touch) {
    const finger = fingers.pop()
    if (finger !== undefined) {
      fingerIds[touch.identifier] = finger
    }
  }

  function forgetTouch(touch: Touch) {
    fingers.push(fingerIds[touch.identifier])
    delete fingerIds[touch.identifier]
  }

  const emitTouchData = (type: number, touches: TouchList) => {
    const data = new DataView(new ArrayBuffer(2 + 7 * touches.length))
    data.setUint8(0, type)
    data.setUint8(1, touches.length)
    let byte = 2
    for (let t = 0; t < touches.length; t++) {
      const touch = touches[t]
      const x = touch.clientX - video.offsetLeft
      const y = touch.clientY - video.offsetTop
      const coord = normalizeAndQuantizeUnsigned(x, y)
      data.setUint16(byte, coord.x, true)
      byte += 2
      data.setUint16(byte, coord.y, true)
      byte += 2
      data.setUint8(byte, fingerIds[touch.identifier])
      byte += 1
      data.setUint8(byte, 255 * touch.force) // force is between 0.0 and 1.0 so quantize into byte.
      byte += 1
      data.setUint8(byte, coord.inRange ? 1 : 0) // mark the touch as in the player or not
      byte += 1
    }
    send(data.buffer)
  }

  if (InputOptions.FakeMouseWithTouches) {
    let finger: FingerRecord | undefined

    video.ontouchstart = (e) => {
      if (finger === undefined) {
        const firstTouch = e.changedTouches[0]
        finger = {
          id: firstTouch.identifier,
          x: firstTouch.clientX - rect.left,
          y: firstTouch.clientY - rect.top,
        }
        // Hack: Mouse events require an enter and leave so we just
        // enter and leave manually with each touch as this event
        // is not fired with a touch device.
        const ev = new MouseEvent('mouseenter')
        video.onmouseenter?.(ev)
        emitMouseDown(MouseButton.MainButton, finger.x, finger.y)
      }
      e.preventDefault()
    }

    video.ontouchend = (e) => {
      for (let t = 0; t < e.changedTouches.length; t++) {
        const touch = e.changedTouches[t]
        if (touch.identifier === finger?.id) {
          const x = touch.clientX - rect.left
          const y = touch.clientY - rect.top
          emitMouseUp(MouseButton.MainButton, x, y)
          // Hack: Manual mouse leave event.
          const ev = new MouseEvent('mouseleave')
          video.onmouseleave?.(ev)
          finger = undefined
          break
        }
      }
      e.preventDefault()
    }

    video.ontouchmove = (e) => {
      for (let t = 0; t < e.touches.length; t++) {
        const touch = e.touches[t]
        if (touch.identifier === finger?.id) {
          const x = touch.clientX - rect.left
          const y = touch.clientY - rect.top
          emitMouseMove(x, y, x - finger.x, y - finger.y)
          finger.x = x
          finger.y = y
          break
        }
      }
      e.preventDefault()
    }
  } else {
    video.ontouchstart = (e) => {
      // Assign a unique identifier to each touch.
      for (let t = 0; t < e.changedTouches.length; t++) {
        rememberTouch(e.changedTouches[t])
      }

      emitTouchData(MessageType.TouchStart, e.changedTouches)
      e.preventDefault()
    }

    video.ontouchend = (e) => {
      emitTouchData(MessageType.TouchEnd, e.changedTouches)

      // Re-cycle unique identifiers previously assigned to each touch.
      for (let t = 0; t < e.changedTouches.length; t++) {
        forgetTouch(e.changedTouches[t])
      }
      e.preventDefault()
    }

    video.ontouchmove = (e) => {
      emitTouchData(MessageType.TouchMove, e.touches)
      e.preventDefault()
    }
  }
}

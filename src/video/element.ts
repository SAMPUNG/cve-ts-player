import { MessageType, WS_OPEN_STATE } from '@cve-ts/dictionary'

import { send } from '../liaison/emitter'
import { ws } from '../liaison/web-socket'
import { emitDebugEvent } from '../player/emitter'
import { onResizePlayerStyle } from '../style/events'

const video = document.createElement('video')
video.disablePictureInPicture = true
video.id = 'streaming-video'
video.muted = true
video.playsInline = true

function onLoadMetadata() {
  if (ws?.readyState === WS_OPEN_STATE) {
    onResizePlayerStyle()

    // Play Video Stream
    video.play().catch(() => {
      emitDebugEvent('play', 'error')
    })
    // Request Initial Settings
    send(new Uint8Array([MessageType.RequestInitialSettings]).buffer)
    // Request Quality Control
    send(new Uint8Array([MessageType.RequestQualityControl]).buffer)
    emitDebugEvent('play', 'start')
  }
}

function onPause() {
  video.play()
}

type VideoFrameParams = [now: number, metadata: VideoFrameCallbackMetadata]
function onVideoFrameReady(...params: VideoFrameParams) {
  const metadata: VideoFrameCallbackMetadata = params[1]
  if (metadata.receiveTime && metadata.expectedDisplayTime) {
    const receiveToCompositeMs =
      metadata.presentationTime - metadata.receiveTime
    emitDebugEvent('composite', receiveToCompositeMs)
  }

  // Re-register the callback to be notified about the next frame.
  video.requestVideoFrameCallback(onVideoFrameReady)
}

video.addEventListener('loadedmetadata', onLoadMetadata, true)
video.addEventListener('pause', onPause)

// Check if request video frame callback is supported
if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
  // The API is supported!
  // Initially register the callback to be notified about the first frame.
  video.requestVideoFrameCallback(onVideoFrameReady)
}

export { video }

export default video

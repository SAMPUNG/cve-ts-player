import { MessageType } from '@cve-ts/dictionary'

import { send } from '../liaison/emitter'

interface ControllerMap {
  [x: number]: ControllerRecord
}
interface ControllerRecord {
  currentState: Gamepad
  prevState: Gamepad
}

const controllers: ControllerMap = {}

export function disposeGamepadEvents() {
  if (window.GamepadEvent !== undefined) {
    window.removeEventListener('gamepadconnected', onGamepadConnect)
    window.removeEventListener('gamepaddisconnected', onGamepadDisconnect)
  } else if (window.WebKitGamepadEvent !== undefined) {
    window.removeEventListener('webkitgamepadconnected', onGamepadConnect)
    window.removeEventListener('webkitgamepaddisconnected', onGamepadDisconnect)
  }
}

function emitControllerAxisMove(
  controllerIndex: number,
  axisIndex: number,
  analogValue: number
) {
  const Data = new DataView(new ArrayBuffer(11))
  Data.setUint8(0, MessageType.GamepadAnalog)
  Data.setUint8(1, controllerIndex)
  Data.setUint8(2, axisIndex)
  Data.setFloat64(3, analogValue, true)
  send(Data.buffer)
}
function emitControllerButtonPressed(
  controllerIndex: number,
  buttonIndex: number,
  isRepeat: number
) {
  const Data = new DataView(new ArrayBuffer(4))
  Data.setUint8(0, MessageType.GamepadButtonPressed)
  Data.setUint8(1, controllerIndex)
  Data.setUint8(2, buttonIndex)
  Data.setUint8(3, isRepeat)
  send(Data.buffer)
}
function emitControllerButtonReleased(
  controllerIndex: number,
  buttonIndex: number
) {
  const Data = new DataView(new ArrayBuffer(3))
  Data.setUint8(0, MessageType.GamepadButtonReleased)
  Data.setUint8(1, controllerIndex)
  Data.setUint8(2, buttonIndex)
  send(Data.buffer)
}

function onGamepadConnect(e: GamepadEvent) {
  const gamepad = e.gamepad
  controllers[gamepad.index] = {
    currentState: gamepad,
    prevState: gamepad,
  }
  raf(updateStatus)
}
function onGamepadDisconnect(e: GamepadEvent) {
  delete controllers[e.gamepad.index]
}

// Request Animation Frame
const raf: (callback: FrameRequestCallback) => number =
  window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.requestAnimationFrame

export function registerGamepadEvents() {
  if (window.GamepadEvent !== undefined) {
    window.addEventListener('gamepadconnected', onGamepadConnect)
    window.addEventListener('gamepaddisconnected', onGamepadDisconnect)
  } else if (window.WebKitGamepadEvent !== undefined) {
    window.addEventListener('webkitgamepadconnected', onGamepadConnect)
    window.addEventListener('webkitgamepaddisconnected', onGamepadDisconnect)
  }
}

function scanGamepads() {
  let gamepads
  if (navigator.getGamepads) {
    gamepads = navigator.getGamepads()
  } else {
    gamepads = navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []
  }
  for (let i = 0; i < gamepads.length; i++) {
    const gamepad = gamepads[i]!
    if (controllers[gamepad.index]) {
      controllers[gamepad.index].currentState = gamepad
    }
  }
}

function updateStatus() {
  scanGamepads()
  // Iterate over multiple controllers in the case the mutiple gamepads are connected
  Object.keys(controllers).forEach((key) => {
    const j = Number(key)
    const controller = controllers[j]
    const { currentState } = controller
    const { prevState } = controller
    // Iterate over buttons
    for (let i = 0; i < currentState.buttons.length; i++) {
      const currButton = currentState.buttons[i]
      const prevButton = prevState.buttons[i]
      // Button 6 is actually the left trigger, send it to UE as an analog axis
      // Button 7 is actually the right trigger, send it to UE as an analog axis
      // The rest are normal buttons. Treat as such
      if (currButton.pressed && !prevButton.pressed) {
        // New press
        if (i === 6) {
          emitControllerAxisMove(j, 5, currButton.value)
        } else if (i === 7) {
          emitControllerAxisMove(j, 6, currButton.value)
        } else {
          emitControllerButtonPressed(j, i, 0)
        }
      } else if (!currButton.pressed && prevButton.pressed) {
        // release
        if (i === 6) {
          emitControllerAxisMove(j, 5, 0)
        } else if (i === 7) {
          emitControllerAxisMove(j, 6, 0)
        } else {
          emitControllerButtonReleased(j, i)
        }
      } else if (currButton.pressed && prevButton.pressed) {
        // repeat press / hold
        if (i === 6) {
          emitControllerAxisMove(j, 5, currButton.value)
        } else if (i === 7) {
          emitControllerAxisMove(j, 6, currButton.value)
        } else {
          emitControllerButtonPressed(j, i, 1)
        }
      }
      // Last case is button isn't currently pressed and wasn't pressed before. This doesn't need an else block
    }
    // Iterate over gamepad axes
    for (let i = 0; i < currentState.axes.length; i += 2) {
      const x = parseFloat(currentState.axes[i].toFixed(4))
      // https://w3c.github.io/gamepad/#remapping Gamepad broweser side standard mapping has positive down, negative up. This is downright disgusting. So we fix it.
      const y = -parseFloat(currentState.axes[i + 1].toFixed(4))
      if (i === 0) {
        // left stick
        // axis 1 = left horizontal
        emitControllerAxisMove(j, 1, x)
        // axis 2 = left vertical
        emitControllerAxisMove(j, 2, y)
      } else if (i === 2) {
        // right stick
        // axis 3 = right horizontal
        emitControllerAxisMove(j, 3, x)
        // axis 4 = right vertical
        emitControllerAxisMove(j, 4, y)
      }
    }
    controllers[j].prevState = currentState
  })
  raf(updateStatus)
}
